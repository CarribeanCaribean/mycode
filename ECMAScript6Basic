读《ECMAScript 6 入门》（阮一峰）学习笔记
一、ECMAScript 6简介
1、Babel转码器
  --配置文件.babelrc。
  --命令行转码babel-cli，Babel提供babel-cli工具，用于命令行转码。
        babel-node，babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。
  --babel-register，babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。
  --babel-core，如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。
  --babel-polyfill，转换JavaScript新的API。
  --Babel提供一个REPL在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。https://babeljs.io/repl/
2、Traceur转码器
  --Google公司的Traceur转码器，也可以将ES6代码转为ES5代码。
  --Traceur允许将ES6代码直接插入网页。
  --Traceur也提供一个在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。http://google.github.io/traceur-compiler/demo/repl.html#
二、let和const命令
1、let命令
  --let命令，用来声明变量，所声明的变量只在let命令所在的代码块内有效。
  --不存在变量提升（var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。），let命令它所声明的变量一定要在声明后使用，否则报错ReferenceError。
  --暂时性死区（temporal dead zone，简称 TDZ），只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。（ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。）
  --不允许重复声明，let不允许在相同作用域内，重复声明同一个变量。
2、块级作用域
  --ES5 只有全局作用域和函数作用域，没有块级作用域。（缺点：内层变量可能会覆盖外层变量。用来计数的循环变量泄露为全局变量。）
  --ES6 的块级作用域，(1)ES6 允许块级作用域的任意嵌套。(2)内层作用域可以定义外层作用域的同名变量。(3)块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
  --（1）允许在块级作用域内声明函数。（2）函数声明类似于var，即会提升到全局作用域或函数作用域的头部。（3）同时，函数声明还会提升到所在的块级作用域的头部。上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。
  --（考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式let f = function () {}，而不是函数声明语句function f() {}。）
  --ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
  --块级作用域是一个语句，将多个操作封装在一起，没有返回值。在块级作用域之前加上do，使它变为do表达式，可以返回值。
3、const 命令
  --const声明一个只读的常量。一旦声明，常量的值就不能改变。（const一旦声明变量，就必须立即初始化，不能留到以后赋值。改变常量的值会报错。）
  --const的作用域与let命令相同：只在声明所在的块级作用域内有效。
  --const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
  --const声明的常量，也与let一样不可重复声明。
  --将一个对象或者数组声明为常量，可以为对象或者数组改变其属性，但是不能使该常量指向另外的对象或者数组。（对象本身是可变的，所以依然可以为其添加新属性。这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。）
  --Object.freeze（），const foo = Object.freeze({});常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。
    将对象彻底冻结的函数：
    var constantize = (obj) => {
      Object.freeze(obj);
      Object.keys(obj).forEach( (key, i) => {
        if ( typeof obj[key] === 'object' ) {
          constantize( obj[key] );
        }
      });
    };
  --ES5 只有两种声明变量的方法：var命令和function命令。ES6一共有6种声明变量的方法：var命令，function命令，let命令，const命令，import命令，class命令。
4、顶层对象的属性
  --顶层对象。在浏览器环境指的是window对象；在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。
  （顶层对象的属性与全局变量挂钩的缺点：
      （1）没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。
      （2）程序员很容易不知不觉地就创建了全局变量（比如打字出错）。
      （3）顶层对象的属性是到处可以读写的，这非常不利于模块化编程。
      （4）window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。）
  --ES6规定var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
5、global 对象
  --都取到顶层对象。下面是两种勉强可以使用的方法。
        // 方法一
        (typeof window !== 'undefined'
           ? window
           : (typeof process === 'object' &&
              typeof require === 'function' &&
              typeof global === 'object')
             ? global
             : this);

        // 方法二
        var getGlobal = function () {
          if (typeof self !== 'undefined') { return self; }
          if (typeof window !== 'undefined') { return window; }
          if (typeof global !== 'undefined') { return global; }
          throw new Error('unable to locate global object');
        };
三、变量的解构赋值
1、解构:ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。let [a, b, c] = [1, 2, 3]。
  --解构不成功：let [bar, foo] = [1];
  --不完全解构：let [a, [b], d] = [1, [2, 3], 4];
  --解构赋值允许指定默认值：let [x, y = 'b'] = ['a']; // x='a', y='b'。
2、对象的解构赋值
  --数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。let { bar, foo } = { foo: "aaa", bar: "bbb" }。let {foo} = {foo: 1}; 或者 let foo;({foo} = {foo: 1})。（let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。）
3、字符串的解构赋值 
  --const [a, b, c, d, e] = 'hello';
4、数值和布尔值的解构赋值
  --解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
5、函数参数的解构赋值
6、圆括号问题
  --不能使用圆括号的情况：（1）变量声明语句中，不能带有圆括号。（2）函数参数中，模式不能带有圆括号。（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。
  --可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号。
7、用途
  --变量的解构赋值用途很多。（1）交换变量的值；（2）从函数返回多个值；（3）函数参数的定义；（4）提取JSON数据；（5）函数参数的默认值；（6）遍历Map结构（任何部署了Iterator接口的对象，都可以用for...of循环遍历）for (let [key, value] of map) {console.log(key + " is " + value);}；（7）输入模块的指定方法。
四、字符串的扩展
1、
