一、ECMAScript 6简介
1、Babel转码器
  --配置文件.babelrc。
  --命令行转码babel-cli，Babel提供babel-cli工具，用于命令行转码。
        babel-node，babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。
  --babel-register，babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。
  --babel-core，如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。
  --babel-polyfill，转换JavaScript新的API。
  --Babel提供一个REPL在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。https://babeljs.io/repl/
2、Traceur转码器
  --Google公司的Traceur转码器，也可以将ES6代码转为ES5代码。
  --Traceur允许将ES6代码直接插入网页。
  --Traceur也提供一个在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。http://google.github.io/traceur-compiler/demo/repl.html#
二、let和const命令
1、let命令
  --let命令，用来声明变量，所声明的变量只在let命令所在的代码块内有效。
  --不存在变量提升（var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。），let命令它所声明的变量一定要在声明后使用，否则报错ReferenceError。
  --暂时性死区（temporal dead zone，简称 TDZ），只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。（ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。）
  --不允许重复声明，let不允许在相同作用域内，重复声明同一个变量。
2、块级作用域
  --ES5 只有全局作用域和函数作用域，没有块级作用域。（缺点：内层变量可能会覆盖外层变量。用来计数的循环变量泄露为全局变量。）
  --ES6 的块级作用域，(1)ES6 允许块级作用域的任意嵌套。(2)内层作用域可以定义外层作用域的同名变量。(3)块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
  --（1）允许在块级作用域内声明函数。（2）函数声明类似于var，即会提升到全局作用域或函数作用域的头部。（3）同时，函数声明还会提升到所在的块级作用域的头部。上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。
  --（考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式let f = function () {}，而不是函数声明语句function f() {}。）
  --ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
  --块级作用域是一个语句，将多个操作封装在一起，没有返回值。在块级作用域之前加上do，使它变为do表达式，可以返回值。
3、const 命令
  --const声明一个只读的常量。一旦声明，常量的值就不能改变。（const一旦声明变量，就必须立即初始化，不能留到以后赋值。改变常量的值会报错。）
  --const的作用域与let命令相同：只在声明所在的块级作用域内有效。
  --const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
  --const声明的常量，也与let一样不可重复声明。
  --将一个对象或者数组声明为常量，可以为对象或者数组改变其属性，但是不能使该常量指向另外的对象或者数组。（对象本身是可变的，所以依然可以为其添加新属性。这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。）
  --Object.freeze（），const foo = Object.freeze({});常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。
    将对象彻底冻结的函数：
    var constantize = (obj) => {
      Object.freeze(obj);
      Object.keys(obj).forEach( (key, i) => {
        if ( typeof obj[key] === 'object' ) {
          constantize( obj[key] );
        }
      });
    };
4、
