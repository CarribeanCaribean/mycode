读《ECMAScript 6 入门》（阮一峰）学习笔记
一、ECMAScript 6简介
1、Babel转码器
  --配置文件.babelrc。
  --命令行转码babel-cli，Babel提供babel-cli工具，用于命令行转码。
        babel-node，babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。
  --babel-register，babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。
  --babel-core，如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。
  --babel-polyfill，转换JavaScript新的API。
  --Babel提供一个REPL在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。https://babeljs.io/repl/
2、Traceur转码器
  --Google公司的Traceur转码器，也可以将ES6代码转为ES5代码。
  --Traceur允许将ES6代码直接插入网页。
  --Traceur也提供一个在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。http://google.github.io/traceur-compiler/demo/repl.html#
二、let和const命令
1、let命令
  --let命令，用来声明变量，所声明的变量只在let命令所在的代码块内有效。
  --不存在变量提升（var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。），let命令它所声明的变量一定要在声明后使用，否则报错ReferenceError。
  --暂时性死区（temporal dead zone，简称 TDZ），只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。（ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。）
  --不允许重复声明，let不允许在相同作用域内，重复声明同一个变量。
2、块级作用域
  --ES5 只有全局作用域和函数作用域，没有块级作用域。（缺点：内层变量可能会覆盖外层变量。用来计数的循环变量泄露为全局变量。）
  --ES6 的块级作用域，(1)ES6 允许块级作用域的任意嵌套。(2)内层作用域可以定义外层作用域的同名变量。(3)块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
  --（1）允许在块级作用域内声明函数。（2）函数声明类似于var，即会提升到全局作用域或函数作用域的头部。（3）同时，函数声明还会提升到所在的块级作用域的头部。上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。
  --（考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式let f = function () {}，而不是函数声明语句function f() {}。）
  --ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
  --块级作用域是一个语句，将多个操作封装在一起，没有返回值。在块级作用域之前加上do，使它变为do表达式，可以返回值。
3、const 命令
  --const声明一个只读的常量。一旦声明，常量的值就不能改变。（const一旦声明变量，就必须立即初始化，不能留到以后赋值。改变常量的值会报错。）
  --const的作用域与let命令相同：只在声明所在的块级作用域内有效。
  --const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
  --const声明的常量，也与let一样不可重复声明。
  --将一个对象或者数组声明为常量，可以为对象或者数组改变其属性，但是不能使该常量指向另外的对象或者数组。（对象本身是可变的，所以依然可以为其添加新属性。这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。）
  --Object.freeze（），const foo = Object.freeze({});常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。
    将对象彻底冻结的函数：
    var constantize = (obj) => {
      Object.freeze(obj);
      Object.keys(obj).forEach( (key, i) => {
        if ( typeof obj[key] === 'object' ) {
          constantize( obj[key] );
        }
      });
    };
  --ES5 只有两种声明变量的方法：var命令和function命令。ES6一共有6种声明变量的方法：var命令，function命令，let命令，const命令，import命令，class命令。
4、顶层对象的属性
  --顶层对象。在浏览器环境指的是window对象；在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。
  （顶层对象的属性与全局变量挂钩的缺点：
      （1）没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。
      （2）程序员很容易不知不觉地就创建了全局变量（比如打字出错）。
      （3）顶层对象的属性是到处可以读写的，这非常不利于模块化编程。
      （4）window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。）
  --ES6规定var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
5、global 对象
  --都取到顶层对象。下面是两种勉强可以使用的方法。
        // 方法一
        (typeof window !== 'undefined'
           ? window
           : (typeof process === 'object' &&
              typeof require === 'function' &&
              typeof global === 'object')
             ? global
             : this);

        // 方法二
        var getGlobal = function () {
          if (typeof self !== 'undefined') { return self; }
          if (typeof window !== 'undefined') { return window; }
          if (typeof global !== 'undefined') { return global; }
          throw new Error('unable to locate global object');
        };
三、变量的解构赋值
1、解构:ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。let [a, b, c] = [1, 2, 3]。
  --解构不成功：let [bar, foo] = [1];
  --不完全解构：let [a, [b], d] = [1, [2, 3], 4];
  --解构赋值允许指定默认值：let [x, y = 'b'] = ['a']; // x='a', y='b'。
2、对象的解构赋值
  --数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。let { bar, foo } = { foo: "aaa", bar: "bbb" }。let {foo} = {foo: 1}; 或者 let foo;({foo} = {foo: 1})。（let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。）
3、字符串的解构赋值 
  --const [a, b, c, d, e] = 'hello';
4、数值和布尔值的解构赋值
  --解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
5、函数参数的解构赋值
6、圆括号问题
  --不能使用圆括号的情况：（1）变量声明语句中，不能带有圆括号。（2）函数参数中，模式不能带有圆括号。（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。
  --可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号。
7、用途
  --变量的解构赋值用途很多。（1）交换变量的值；（2）从函数返回多个值；（3）函数参数的定义；（4）提取JSON数据；（5）函数参数的默认值；（6）遍历Map结构（任何部署了Iterator接口的对象，都可以用for...of循环遍历）for (let [key, value] of map) {console.log(key + " is " + value);}；（7）输入模块的指定方法。
四、字符串的扩展
1、字符的Unicode表示法
  --JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点"\u0061"，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达"\uD842\uDFB7"。
  --ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。如："\u{20BB7}"，'\u{1F680}' === '\uD83D\uDE80'。
  --JavaScript共有6种方法可以表示一个字符。
      '\z' === 'z'  // true
      '\172' === 'z' // true
      '\x7A' === 'z' // true
      '\u007A' === 'z' // true
      '\u{7A}' === 'z' // true
2、codePointAt()
  --ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。
  --codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。s.codePointAt(0).toString(16) // "20bb7"
3、String.fromCodePoint()
  --ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。
4、字符串的遍历器接口
  --ES6为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。
        for (let codePoint of 'foo') {
          console.log(codePoint)
        }
        // "f"
        // "o"
        // "o"
  --除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。
        var text = String.fromCodePoint(0x20BB7);
        for (let i of text) {
          console.log(i);
        }
        // "𠮷"
5、at()
  --ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。提出字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。
    '𠮷'.charAt(0) // "\uD842"
    '𠮷'.at(0) // "𠮷"
6、normalize()
  --normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值：NFC，默认参数，表示“标准等价合成”；NFD，表示“标准等价分解”；NFKC，表示“兼容等价合成”；NFKD，表示“兼容等价分解”。
7、includes(), startsWith(), endsWith()
  --这三个方法都支持第二个参数，表示开始搜索的位置。使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。
  --includes()：返回布尔值，表示是否找到了参数字符串。
  --startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
  --endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。
8、repeat() 
  --repeat方法返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整。如果repeat的参数是负数或者Infinity，会报错。如果参数是0到-1之间的小数，则等同于0。参数NaN等同于0。
9、padStart()，padEnd()
  --ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。
      'x'.padStart(4, 'ab') // 'abax'；
      'x'.padEnd(4, 'ab') // 'xaba'；
  --如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。
  --如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。
  --如果省略第二个参数，默认使用空格补全长度。
  --padStart的常见用途是为数值补全指定位数，'1'.padStart(10, '0') // "0000000001"。另一个用途是提示字符串格式，'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"。
10、模板字符串
  --模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
  --如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。如果你不想要这个换行，可以使用trim方法消除它。
  --模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。
          // 普通字符串
          `In JavaScript '\n' is a line-feed.`

          // 多行字符串
          `In JavaScript this is
           not legal.`

          console.log(`string text line 1
          string text line 2`);

          // 字符串中嵌入变量
          var name = "Bob", time = "today";
          `Hello ${name}, how are you ${time}?`
11、标签模板
  --模板字符串，它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。
  --标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。
12、String.raw()
13、模板字符串的限制
  --前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。
  --为了解决这个问题，现在有一个提案，放松对标签模板里面的字符串转义的限制。模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了。
  --注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。
五、正则的扩展
