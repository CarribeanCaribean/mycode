一、ECMAScript 6简介
1、Babel转码器
  --配置文件.babelrc。
  --命令行转码babel-cli，Babel提供babel-cli工具，用于命令行转码。
        babel-node，babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。
  --babel-register，babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。
  --babel-core，如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。
  --babel-polyfill，转换JavaScript新的API。
  --Babel提供一个REPL在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。https://babeljs.io/repl/
2、Traceur转码器
  --Google公司的Traceur转码器，也可以将ES6代码转为ES5代码。
  --Traceur允许将ES6代码直接插入网页。
  --Traceur也提供一个在线编译器，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。http://google.github.io/traceur-compiler/demo/repl.html#
二、let和const命令
1、let命令
  --let命令，用来声明变量，所声明的变量只在let命令所在的代码块内有效。
  --不存在变量提升（var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。），let命令它所声明的变量一定要在声明后使用，否则报错ReferenceError。
  --暂时性死区（temporal dead zone，简称 TDZ），只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。（ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。）
  --不允许重复声明，let不允许在相同作用域内，重复声明同一个变量。
2、块级作用域
  --ES5 只有全局作用域和函数作用域，没有块级作用域。（缺点：内层变量可能会覆盖外层变量。用来计数的循环变量泄露为全局变量。）
  --ES6 的块级作用域，(1)ES6 允许块级作用域的任意嵌套。(2)内层作用域可以定义外层作用域的同名变量。(3)块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
  --（1）允许在块级作用域内声明函数。（2）函数声明类似于var，即会提升到全局作用域或函数作用域的头部。（3）同时，函数声明还会提升到所在的块级作用域的头部。上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。
  --（考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式let f = function () {}，而不是函数声明语句function f() {}。）
  --ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
3、
4、
